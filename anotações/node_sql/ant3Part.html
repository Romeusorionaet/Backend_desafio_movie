

<p>
    Agora vou criar a parte inteligente que processa as requisisões, o controller. A camada que faz a 
    verificação, a validação de entrada de dados.
    Sabemos que o server.js é o ponto de entrada e logo em seguinda vem as rotas e das rotas vai ser entrefue 
    ao um determinado controller que execulta essa requisição devolvendeo para a rota.
</p>

<p>
    Criando uma pasta dentro de src "controller", crio um arquivo dentro dessa pasta, arquivo MovieController.
    Aqui vou fazer a parte inteligente do processo, vamos validar entre outras coisas.
</p>

<h2>Arquivo MovieController</h2>

<p>
    Nesse arquivo usamos classes porque permite usarmos várias funções, porém existe um padrão para seguirmos.
    Em um controller só pode no máximo 5 métodos(funções)
</p>

<h2>Padrão</h2>

<ul>
    <li>index - GET para listar vários registros.</li>
    <li>show - GET para exibir um registro expecífico.</li>
    <li>create - POST para criar um registro.</li>
    <li>update - PUT para atualizar um registro.</li>
    <li>delete - DELETE para remover um registro</li>
</ul>

<p>
    Um controller pode ter todos esses 5 ou apenas 1, mas não é bom ter mais de 5 pois é melhor criar outro controller
</p>

<p>
    Explicando uma pequena parte da classe criada:

    class MovieController {
        create(req, res) {
            
        }
    }

    Aqui temos a classe o create é uma função, porém não precisamos usar a palavra chave function porque ela está dentro de um classe.
</p>

<p>
    Como agora o controller vai ficar responsável pelo processo, então pegamos da rota a parte:
    const {name, description, note} = req.body;
     res.json(`name movie: ${name} description: ${description} note: ${note}`);
     E colocamos dentro de create. Agora temos que exportar MovieController para dentro da rota para a rota 
     ter acesso a esse controller caso for solicitado.
</p>

<p>
    Como vamos importar dentro de movie.router.js, o MovieController.js por ser uma classe temos que instanciar
    ela para poder fazer uso, fazemos assim:

    const MovieController = require("../controllers/MovieController") Importando
    const movieController = new MovieController(); Instanciando
</p>

<h2>Middlewares</h2>

<p>
    Os Middlewares tem acesso as requicisões antes de seu destino. Ele age como um segurança
    que faz uma verificação. Tendo acesso também ao destino da requisição. Seu padrão é seguir com a próxima função
    se for necessário, função essa denotada por uma variável chamada next.
</p>

<h3>O que os Middlewares podem fazer</h3>

<ul>
    <li>Executar qualquer código</li>
    <li>Fazer mudanças nos objetos de solicitação e resposta</li>
    <li>Encerrar o ciclo de solicitação e reposta</li>
    <li>Chamar o próximo Middlewares na pilha</li>
</ul>

<p>
    O local de uso dos Middlewares são nas rotas na raiz. exp:
    movieRoutes.post("/", myMiddleware movieController.create)
</p>

<h2>Utils</h2>

<p>
    Agora vamos criar a pasta Utils e nele vamos criar um arquivo AppError.js para cuidar que nossa aplicação continue funcionando
    caso ocorra alguma exeção. Então vamos padronizar que tipo de mensagem vai aparecer caso isso ocorra.
</p>

<p>
    Vamos dentro desse arquivo criar uma classe e dentro de temos um método construtor() que ele roda automaticamente sempre 
    que a classe é estânciada. 

    Nossa classe de error:

    class AppError {
        message;
        statusCode;
    
        constructor(message, statusCode = 400){
            this.message = message;
            this.statusCode = statusCode;
        }
    }    
</p>

<p>
    Para fazer uso dele temos que importar, no caso usando require no controller e fazer uso dele na condição lógica do código.
    Mas precisamos de instalar usando o npm install express-async-errors --save no terminal 
    para instalar uma bíblioteca de erros para podermos usar o AppError.
</p>

<p>
    Faremos isto no arquivo server.js, lá importamos e usamos dentro de app.use um if()
    e para saber se o error vem do cliente a lógica é a seguinte: (error instanceof AppError)
    Esse erro é para o cliente caso ele não informe o nome por exemplo.
</p>

